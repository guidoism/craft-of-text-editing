This text editor is essentially just a SECD machine optimized for
representing buffers of text in a format that is useful for editing
operations and typesetting it to a display.

** Buffers

Everything is a buffer. That statement is not quite true, but it's
true enough. Files that we edit are loading into a buffer. When we
start a new file we start with an empty buffer and later bind it to
and save it to a file. Commands are typed into a (mini-) buffer.
Background status is stored in buffers. This is the magic that makes
Emacs so hackable.

A text file is a one-dimensional representation of a two-dimensional
document. For example, newlines are control characters that describe
how to convert the file into the 2d plane of glyphs.

This is an important point to remember. There's nothing sacred about
drawing one character at a time, from left to right, and when we get
to the right of the display wrapping to the next line by moving down
the glyph height and starting again at the far left and doing the
same when we reach a newline character instead of drawing it.

Painting a sequence of glyphs across the screen in a zig-zag is pretty
universal for text, but the direction you move isn't.

In fact, we will almost certainly want to visualize a sequence of
characters in different ways. For example: wrapping long lines vs
truncation.

And this brings up another difference, do we want the cursor to move
around the screen without any regard to the structure of the text
under it or does "move up" for example really mean move to the
previous line at the same column offset? And what happens if the
previous line is too short and doesn't have that column? And what
happens if you keep moving up and encounter another line that /is/
long enough? 

Mentally de-coupling the sequence of characters in a buffer with the
visualization opens up other potential improvements. Maybe we can also
display a PDF as either the textual format or as the drawn document
the author intended. Or we could constrain code files to always be
syntactically correct.

*** Buffer Representation

The choice of data structure for a buffer of text is dependent several
factors most notably how much text, whether it is full of many short
lines or few long lines, and whether it will be mostly just read or is
under active editing.

We recognized that we don't have to use the same data structure for
all active buffer nor even the same data structure for the buffer over
its lifetime.

**** Gap Buffers

In the actual implementation they use Gap Buffers. A buffer
initial starts off all gap, the first part is 0 length at
the beginning and the second part is 0 length at the end.

**** Naive Buffer

Before we implement the more complex gap buffer we will
implement the most naive form of buffer. Just a flat piece
of memory that comes from malloc. We move everything after
the insertion point with ~memmove~ during each edit.

#+name: buffer_representation
#+begin_src c
typedef struct Buffer {
  BufferId id;
  String name;
  u8* contents;
  u64 length;
  u64 point;
  // Mark mark; no need to this quite yet
  
} Buffer;

Buffer buffers[64];
u16 buffers_len;
BufferId current_buffer_id;
#+end_src

*** Create a new buffer

#+name: create_buffer
#+begin_src c
Status create_buffer(String name) {
  for (int i = 0; i < buffers_len; i++) {
    if (memcmp(buffers[i].name.s, name.s, name.len) == 0) {
      return Failure;
    }
  }
  int i = buffers_len++;
  Buffer * b = &buffers[i];
  b->id = i;
  b->name = name;
  b->contents = malloc(100);
  return Success;
}

Status set_current_buffer(String name) {
  for (int i = 0; i < buffers_len; i++) {
    if (memcmp(buffers[i].name.s, name.s, name.len) == 0) {
      current_buffer_id = i;
    }
  }
  return Failure;
}
#+end_src

*** Insert a character

Insert the character that has been typed.

The universal argument is assumed to be the number of times to repeat
the character being inserted.

#+name: insert_char
#+begin_src c
Status insert_char(u21 ch) {
  u8 * b = buffers[current_buffer_id].contents;
  u64 loc = buffers[current_buffer_id].point;
  printf("Inserting %d to location %llu\n", ch, loc);
  u8 enc[4];
  u8 n = to_utf8(enc, ch);
  if (n == 0) return NotUnicode;
  memmove(b+loc+n, b+loc, n);
  memcpy(b+loc, enc, n);
  buffers[current_buffer_id].point++;
  buffers[current_buffer_id].length += n;
  return Success;
}
#+end_src

*** Unicode Helpers

#+name: unicode_helpers
#+begin_src c
typedef struct String { u8 len; u8 s[64]; } String;
String str(const char * x) {
  // TODO: assert string length
  String y = {.len=sizeof(x)};
  memcpy(y.s, x, y.len);
  return y;
}

u8 to_utf8(u8 * buf, u21 ch)
{
    if (ch <= 0x7F) {
        buf[0] = ch;
        return 1;
    }
    if (ch <= 0x7FF) {
        buf[0] = 0xC0 | (ch >> 6);            /* 110xxxxx */
        buf[1] = 0x80 | (ch & 0x3F);          /* 10xxxxxx */
        return 2;
    }
    if (ch <= 0xFFFF) {
        buf[0] = 0xE0 | (ch >> 12);           /* 1110xxxx */
        buf[1] = 0x80 | ((ch >> 6) & 0x3F);   /* 10xxxxxx */
        buf[2] = 0x80 | (ch & 0x3F);          /* 10xxxxxx */
        return 3;
    }
    if (ch <= 0x10FFFF) {
        buf[0] = 0xF0 | (ch >> 18);           /* 11110xxx */
        buf[1] = 0x80 | ((ch >> 12) & 0x3F);  /* 10xxxxxx */
        buf[2] = 0x80 | ((ch >> 6) & 0x3F);   /* 10xxxxxx */
        buf[3] = 0x80 | (ch & 0x3F);          /* 10xxxxxx */
        return 4;
    }
    return 0;
}
#+end_src

** Display

#+name: redisplay
#+begin_src c
Status redisplay(void) {
  printf("Buffer: %s\n", buffers[current_buffer_id].contents);
  return Success;
}
#+end_src

** Setup

#+name: typedefs
#+begin_src c :tangle build/third.c :noweb yes
#include <stdint.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
typedef uint8_t u8;
typedef uint16_t u16;
typedef uint32_t u21; // unicode code point, only use 21 bits
typedef uint32_t u32;
typedef int64_t i64;
typedef uint64_t u64;
typedef uint8_t Status;
typedef uint16_t BufferId;
//typedef char[8] Slug; // a short string (≤ 8 bytes)

enum {Success,Failure,NotUnicode};

<<unicode_helpers>>
<<buffer_representation>>
<<create_buffer>>
<<insert_char>>
<<redisplay>>

int main(void) {
  create_buffer(str("*scratch*"));
  set_current_buffer(str("*scratch*"));
  insert_char('g');
  insert_char('u');
  insert_char('i');
  insert_char('d');
  insert_char('o');
  redisplay();
  return 0;
}

#+end_src

** Extensions
*** Lisp Nodes

The classic C implementation of a Lisp node is an implicit tagged
union of the native word size where the lower 3 bits of a pointer tag
the data that it points to and structs in the array-of-structs style.

The modern style is for a struct-of-arrays where we have large
contiguous swaths of identially typed data. We are going to assume a
64 bit native word size here for simplicity. I can think of no good
reason to make this program optimized for other word sizes. If it is
then the hypothetical 32-bit word size advocate is encouraged to fork
this codebase.

A block of 64 cells (4096 bytes) is a natural point of segmentation.
This allows flags for all 64 cells to each fit into a single 64 bit
word.

#+begin_src c
typedef struct Cons {
  u32 car;
  u32 cde;
} Cons;

typedef struct Cell {
  union {
    i64  n;
    u21  c; // unicode codepoint
    //Slug s;
    Cons p;
  } 
} Cell;

enum Tag {Number, Character, Slug, ConsPair};

Tag  tags[4096];
Cell cells[4096];
#+end_src



** TextMode vs Graphics

Using Sokol, to build:

#+begin_src sh
cd sokol-samples/sapp
../../sokol-tools-bin/bin/osx/sokol-shdc -i cube-sapp.glsl -o cube-sapp.glsl.h -l metal_macos
cc cube-sapp.c ../libs/sokol/sokol.m -o cube-sapp -DSOKOL_METAL -fobjc-arc -I../../sokol -I ../libs -framework Metal -framework Cocoa -framework MetalKit -framework Quartz -framework AudioToolbox
#+end_src

#+name: sokolmain
#+begin_src c :tangle build/third-sokol.c :noweb yes
#include "sokol_app.h"
#include "sokol_gfx.h"
#include "sokol_fetch.h"
#include "sokol_log.h"
#include "sokol_glue.h"
#define SOKOL_GL_IMPL
#include "sokol_gl.h"
#include <stdio.h>  // needed by fontstash's IO functions even though they are not used
#define FONTSTASH_IMPLEMENTATION
#if defined(_MSC_VER )
#pragma warning(disable:4996)   // strncpy use in fontstash.h
#endif
#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-function"
#pragma GCC diagnostic ignored "-Wsign-conversion"
#endif
#include "fontstash/fontstash.h"
#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic pop
#endif
#define SOKOL_FONTSTASH_IMPL
#include "sokol_fontstash.h"
#include "dbgui/dbgui.h"
//#include "util/fileutil.h"


#include <stdint.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
typedef uint8_t u8;
typedef uint16_t u16;
typedef uint32_t u21; // unicode code point, only use 21 bits
typedef uint32_t u32;
typedef int64_t i64;
typedef uint64_t u64;
typedef uint8_t Status;
typedef uint16_t BufferId;
//typedef char[8] Slug; // a short string (≤ 8 bytes)

enum {Success,Failure,NotUnicode};

<<unicode_helpers>>
<<buffer_representation>>
<<create_buffer>>
<<insert_char>>
<<redisplay>>

int mymain(void) {
  create_buffer(str("*scratch*"));
  set_current_buffer(str("*scratch*"));
  insert_char('g');
  insert_char('u');
  insert_char('i');
  insert_char('d');
  insert_char('o');
  redisplay();
  return 0;
}

typedef struct {
    FONScontext* fons;
    float dpi_scale;
    int font_normal;
    int font_italic;
    int font_bold;
    uint8_t font_normal_data[256 * 1024];
    uint8_t font_italic_data[256 * 1024];
    uint8_t font_bold_data[256 * 1024];
} state_t;
static state_t state;

/* optional memory allocation function overrides (see sfons_create()) */
static void* my_alloc(size_t size, void* user_data) {
    (void)user_data;
    return malloc(size);
}

static void my_free(void* ptr, void* user_data) {
    (void)user_data;
    free(ptr);
}

/* sokol-fetch load callbacks */
static void font_normal_loaded(const sfetch_response_t* response) {
    if (response->fetched) {
        state.font_normal = fonsAddFontMem(state.fons, "sans", (void*)response->data.ptr, (int)response->data.size,  false);
    }
}

static void font_italic_loaded(const sfetch_response_t* response) {
    if (response->fetched) {
        state.font_italic = fonsAddFontMem(state.fons, "sans-italic", (void*)response->data.ptr, (int)response->data.size, false);
    }
}

static void font_bold_loaded(const sfetch_response_t* response) {
    if (response->fetched) {
        state.font_bold = fonsAddFontMem(state.fons, "sans-bold", (void*)response->data.ptr, (int)response->data.size, false);
    }
}

/* round to next power of 2 (see bit-twiddling-hacks) */
static int round_pow2(float v) {
    uint32_t vi = ((uint32_t) v) - 1;
    for (uint32_t i = 0; i < 5; i++) {
        vi |= (vi >> (1<<i));
    }
    return (int) (vi + 1);
}

static void init(void) {
    state.dpi_scale = sapp_dpi_scale();
    sg_setup(&(sg_desc){
        .context = sapp_sgcontext(),
        .logger.func = slog_func,
    });
    __dbgui_setup(sapp_sample_count());
    sgl_setup(&(sgl_desc_t){
        .logger.func = slog_func
    });

    /* make sure the fontstash atlas width/height is pow-2 */
    const int atlas_dim = round_pow2(512.0f * state.dpi_scale);
    FONScontext* fons_context = sfons_create(&(sfons_desc_t){
        .width = atlas_dim,
        .height = atlas_dim,
        // allocator functions are optional, just check if it works
        .allocator = {
            .alloc = my_alloc,
            .free = my_free,
        }
    });
    state.fons = fons_context;
    state.font_normal = FONS_INVALID;
    state.font_italic = FONS_INVALID;
    state.font_bold = FONS_INVALID;

    /* use sokol_fetch for loading the TTF font files */
    sfetch_setup(&(sfetch_desc_t){
        .num_channels = 1,
        .num_lanes = 4,
        .logger.func = slog_func,
    });
    char path_buf[512];
    sfetch_send(&(sfetch_request_t){
        .path = "/Users/guido/Library/Fonts/MinionPro-Regular.otf",
        .callback = font_normal_loaded,
        .buffer = SFETCH_RANGE(state.font_normal_data),
    });
    sfetch_send(&(sfetch_request_t){
        .path = "/Users/guido/Library/Fonts/MinionPro-Regular.otf",
        .callback = font_italic_loaded,
        .buffer = SFETCH_RANGE(state.font_italic_data),
    });
    sfetch_send(&(sfetch_request_t){
        .path = "/Users/guido/Library/Fonts/MinionPro-Regular.otf",
        .callback = font_bold_loaded,
        .buffer = SFETCH_RANGE(state.font_bold_data),
    });
}

static void line(float sx, float sy, float ex, float ey)
{
    sgl_begin_lines();
    sgl_c4b(255, 255, 0, 128);
    sgl_v2f(sx, sy);
    sgl_v2f(ex, ey);
    sgl_end();
}

static void frame(void) {
    const float dpis = state.dpi_scale;

    /* pump sokol_fetch message queues */
    sfetch_dowork();

    /* text rendering via fontstash.h */
    float sx, sy, dx, dy, lh = 0.0f;
    uint32_t white = sfons_rgba(255, 255, 255, 255);
    uint32_t black = sfons_rgba(0, 0, 0, 255);
    uint32_t brown = sfons_rgba(192, 128, 0, 128);
    uint32_t blue  = sfons_rgba(0, 192, 255, 255);
    fonsClearState(state.fons);

    sgl_defaults();
    sgl_matrix_mode_projection();
    sgl_ortho(0.0f, sapp_widthf(), sapp_heightf(), 0.0f, -1.0f, +1.0f);

    sx = 50*dpis; sy = 50*dpis;
    dx = sx; dy = sy;

    FONScontext* fs = state.fons;
    if (state.font_normal != FONS_INVALID) {
        fonsSetFont(fs, state.font_normal);
        fonsSetSize(fs, 124.0f*dpis);
        fonsVertMetrics(fs, NULL, NULL, &lh);
        dx = sx;
        dy += lh;
        fonsSetColor(fs, white);
        dx = fonsDrawText(fs, dx, dy, "The quick ", NULL);
    }
    if (state.font_italic != FONS_INVALID) {
        fonsSetFont(fs, state.font_italic);
        fonsSetSize(fs, 48.0f*dpis);
        fonsSetColor(fs, brown);
        dx = fonsDrawText(fs, dx, dy, "brown ", NULL);
    }
    if (state.font_normal != FONS_INVALID) {
        fonsSetFont(fs, state.font_normal);
        fonsSetSize(fs, 24.0f*dpis);
        fonsSetColor(fs, white);
        dx = fonsDrawText(fs, dx, dy,"fox ", NULL);
    }
    if ((state.font_normal != FONS_INVALID) && (state.font_italic != FONS_INVALID) && (state.font_bold != FONS_INVALID)) {
        fonsVertMetrics(fs, NULL, NULL, &lh);
        dx = sx;
        dy += lh*1.2f;
        fonsSetFont(fs, state.font_italic);
        dx = fonsDrawText(fs, dx, dy, "jumps over ",NULL);
        fonsSetFont(fs, state.font_bold);
        dx = fonsDrawText(fs, dx, dy, "the lazy ",NULL);
        fonsSetFont(fs, state.font_normal);
        dx = fonsDrawText(fs, dx, dy, "dog.",NULL);
    }
    if (state.font_normal != FONS_INVALID) {
        dx = sx;
        dy += lh*1.2f;
        fonsSetSize(fs, 12.0f*dpis);
        fonsSetFont(fs, state.font_normal);
        fonsSetColor(fs, blue);
        fonsDrawText(fs, dx,dy,"Now is the time for all good men to come to the aid of the party.",NULL);
    }
    if (state.font_italic != FONS_INVALID) {
        fonsVertMetrics(fs, NULL, NULL, &lh);
        dx = sx;
        dy += lh*1.2f*2;
        fonsSetSize(fs, 18.0f*dpis);
        fonsSetFont(fs, state.font_italic);
        fonsSetColor(fs, white);
        fonsDrawText(fs, dx, dy, "Ég get etið gler án þess að meiða mig.", NULL);
    }

    /* Font alignment */
    if (state.font_normal != FONS_INVALID) {
        fonsSetSize(fs, 18.0f*dpis);
        fonsSetFont(fs, state.font_normal);
        fonsSetColor(fs, white);
        dx = 50*dpis; dy = 350*dpis;
        line(dx-10*dpis,dy,dx+250*dpis,dy);
        fonsSetAlign(fs, FONS_ALIGN_LEFT | FONS_ALIGN_TOP);
        dx = fonsDrawText(fs, dx,dy,"Top",NULL);
        dx += 10*dpis;
        fonsSetAlign(fs, FONS_ALIGN_LEFT | FONS_ALIGN_MIDDLE);
        dx = fonsDrawText(fs, dx,dy,"Middle",NULL);
        dx += 10*dpis;
        fonsSetAlign(fs, FONS_ALIGN_LEFT | FONS_ALIGN_BASELINE);
        dx = fonsDrawText(fs, dx,dy,"Baseline",NULL);
        dx += 10*dpis;
        fonsSetAlign(fs, FONS_ALIGN_LEFT | FONS_ALIGN_BOTTOM);
        fonsDrawText(fs, dx,dy,"Bottom",NULL);
        dx = 150*dpis; dy = 400*dpis;
        line(dx,dy-30*dpis,dx,dy+80.0f*dpis);
        fonsSetAlign(fs, FONS_ALIGN_LEFT | FONS_ALIGN_BASELINE);
        fonsDrawText(fs, dx,dy,"Left",NULL);
        dy += 30*dpis;
        fonsSetAlign(fs, FONS_ALIGN_CENTER | FONS_ALIGN_BASELINE);
        fonsDrawText(fs, dx,dy,"Center",NULL);
        dy += 30*dpis;
        fonsSetAlign(fs, FONS_ALIGN_RIGHT | FONS_ALIGN_BASELINE);
        fonsDrawText(fs, dx,dy,"Right",NULL);
    }

    /* Blur */
    if (state.font_italic != FONS_INVALID) {
        dx = 500*dpis; dy = 350*dpis;
        fonsSetAlign(fs, FONS_ALIGN_LEFT | FONS_ALIGN_BASELINE);
        fonsSetSize(fs, 60.0f*dpis);
        fonsSetFont(fs, state.font_italic);
        fonsSetColor(fs, white);
        fonsSetSpacing(fs, 5.0f*dpis);
        fonsSetBlur(fs, 10.0f);
        fonsDrawText(fs, dx,dy,"Blurry...",NULL);
    }

    if (state.font_bold != FONS_INVALID) {
        dy += 50.0f*dpis;
        fonsSetSize(fs, 18.0f*dpis);
        fonsSetFont(fs, state.font_bold);
        fonsSetColor(fs, black);
        fonsSetSpacing(fs, 0.0f);
        fonsSetBlur(fs, 3.0f);
        fonsDrawText(fs, dx,dy+2,"DROP THAT SHADOW",NULL);
        fonsSetColor(fs, white);
        fonsSetBlur(fs, 0);
        fonsDrawText(fs, dx,dy,"DROP THAT SHADOW",NULL);
    }

    /* flush fontstash's font atlas to sokol-gfx texture */
    sfons_flush(fs);

    /* render pass */
    sg_begin_default_pass(&(sg_pass_action){
        .colors[0] = {
            .action = SG_ACTION_CLEAR, .value = { 0.3f, 0.3f, 0.32f, 1.0f }
        }
    }, sapp_width(), sapp_height());
    sgl_draw();
    __dbgui_draw();
    sg_end_pass();
    sg_commit();
}

static void cleanup(void) {
    __dbgui_shutdown();
    sfetch_shutdown();
    sfons_destroy(state.fons);
    sgl_shutdown();
    sg_shutdown();
}

sapp_desc sokol_main(int argc, char* argv[]) {
    (void)argc;
    (void)argv;
    return (sapp_desc) {
        .init_cb = init,
        .frame_cb = frame,
        .cleanup_cb = cleanup,
        .event_cb = __dbgui_event,
        .width = 800,
        .height = 600,
        .high_dpi = true,
        .gl_force_gles2 = true,
        .window_title = "fontstash",
        .icon.sokol_default = true,
        .logger.func = slog_func,
    };
}


#+end_src


#+begin_src sh
clang build/third-sokol.c experiments/sokol.m \
   -o build/third-sokol -DSOKOL_METAL \
   -fobjc-arc -Iexperiments/ \
   -framework Metal \
   -framework Cocoa \
   -framework MetalKit \
   -framework Quartz \
   -framework AudioToolbox
#+end_src

#+RESULTS:


** Stupid Ideas

- Maybe a slug should store 7 bit ascii chars and use the remaining
  bits for length?
- When loading a file we can write out the text pretty quickly into a
  block of cells and then write out the car/cdr parts in a different
  part of the block all at once.


** Questions

- How many ms does it take to redisplay the whole display? Is it less
  than an incremental approach on a modern computer?
