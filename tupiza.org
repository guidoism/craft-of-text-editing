In this one we are basically just doing exactly what The Craft of Text
Editing says to do, in that order.

** Buffers (and the World)

#+begin_src zig :tangle build/editor.zig
const std = @import("std");

const FileNameMax = 64; 
const BufferNameMax = 64;
const ModeNameMax = 64;

const Status = struct {
};

const World = struct {
    buffer_chain: ?*Buffer,
    current_buffer: ?*Buffer,

    fn init() Status {
    }

    fn fini() Status {
    }

    fn save(filename: []u8) Status {
        std.debug.print("TODO: {}\n", .{filename});
    }

    fn load(filename: []u8) Status {
        std.debug.print("TODO: {}\n", .{filename});
    }
};
var world = World{};

const Buffer = struct {
    next_chain_entry: ?*Buffer,
    buffer_name: [BufferNameMax]u8,

    point: Location,
    cur_line: u32,
    num_chars: u32,
    num_lines: u32,

    mark_list: ?*Mark,
    contents: ?*Storage,

    file_name: [FileNameMax]u8,
    file_time: Time,
    is_modified: bool,

    mode_list: ?*Mode,

    fn create(name: []u8) Status {
        std.debug.print("TODO: {}\n", .{name});
    }
    
    fn clear(name: []u8) Status {
        std.debug.print("TODO: {}\n", .{name});
    }
    
    fn delete(name: []u8) Status {
        std.debug.print("TODO: {}\n", .{name});
    }
    
    fn setCurrent(name: []u8) Status {
        std.debug.print("TODO: {}\n", .{name});
    }
    
    fn setNext() []u8 {
    }
    
    fn setName(name: []u8) Status {
        std.debug.print("TODO: {}\n", .{name});
    }
    
    fn getName() []u8 {
    }
    
};

const Location = struct {
    i: u32 = 0,
};

const Mark = struct {
    next_mark: ?*Mark,
    name: ?*MarkName,
    where_it_is: Location,
    is_fixed: bool,
};

const Mode = struct {
    next_mode: ?*Mode,
    mode_name: [ModeNameMax]u8,
    add_proc: *const fn () Status,
};

const Storage = struct {};
const MarkName = struct {};
const Time = struct {};

#+end_src
