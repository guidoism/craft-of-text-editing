In this one we are basically just doing exactly what The Craft of Text
Editing says to do, in that order.

** Buffers (and the World)

#+begin_src zig :tangle build/editor.zig :noweb yes
const std = @import("std");

const FileNameMax = 64; 
const BufferNameMax = 64;
const ModeNameMax = 64;

const Status = enum {
    ok,
    failed,
};

const Error = error{
    failed,
};

const World = struct {
    buffer_chain: ?*Buffer,
    current_buffer: ?*Buffer,

    pub fn init() Status {
        _ = Buffer.create("*scratch*");
        //Buffer.setCurrent("*scratch*");
        return Status.ok;
    }

    fn fini() Status {
    }

    fn save(filename: []u8) Status {
        std.debug.print("TODO: {}\n", .{filename});
    }

    fn load(filename: []u8) Status {
        std.debug.print("TODO: {}\n", .{filename});
    }
};

var world = World{.buffer_chain=undefined, .current_buffer=undefined};

const Buffer = struct {
    const Self = @This();
    
    next_chain_entry: ?*Buffer = undefined,
    name: [BufferNameMax]u8 = undefined,

    point: Location = {},
    cur_line: u32 = 0,
    num_chars: u32 = 0,
    num_lines: u32 = 0,

    mark_list: ?*Mark = undefined,
    contents: ?*Storage = undefined,

    file_name: [FileNameMax]u8 = undefined,
    file_time: Time = undefined,
    is_modified: bool = false,

    mode_list: ?*Mode = undefined,

    fn create(name: []const u8) Error!Buffer {
        // TODO: confirm that no buffer already has this name
        var buf = Buffer{};
        std.mem.copy(u8, &buf.name, name);
        // TODO: create a Storage for contents
        // TODO: add to world?
        return buf;
    }
    
    fn insertChar(self: Self, c: u8) Status {
        self.context[self.point] = c;
        //advance(b.point);
    }
    
    fn clear(name: []u8) Status {
        std.debug.print("TODO: {}\n", .{name});
    }
    
    fn delete(name: []u8) Status {
        std.debug.print("TODO: {}\n", .{name});
    }
    
    fn setCurrent(name: []u8) Status {
        std.debug.print("TODO: {}\n", .{name});
    }
    
    fn setNext() []u8 {
    }
    
    fn setName(name: []u8) Status {
        std.debug.print("TODO: {}\n", .{name});
    }
    
    fn getName() []u8 {
    }

};

const Location = struct {
    i: u32 = 0,
};

const Mark = struct {
    next_mark: ?*Mark,
    name: ?*MarkName,
    where_it_is: Location,
    is_fixed: bool,
};

const Mode = struct {
    next_mode: ?*Mode,
    mode_name: [ModeNameMax]u8,
    add_proc: *const fn () Status,
};

const Storage = struct {};
const MarkName = struct {};
const Time = struct {};

<<buffergap>>
<<main>>    
#+end_src


** Buffer Gap

1. User coordinate system
2. Gap coordinate system
3. Storage coordinate system

Coordinate positions for 1 and 2 always refer to the space /in
between/ the characters. It makes the math easier. We keep track of
the position where the gap starts and the the position where the gap
ends.

#+name: buffergap
#+begin_src zig
const BufferGap = struct {
    
};
#+end_src


#+name: main
#+begin_src zig
pub fn main() void {
    //_ = World.init();
    //var b = world.current_buffer;
    //b.insertChar('v');
    //Buffer.insertChar(b.*, 'v');
    var b = Buffer.create("*scratch*");
    b.insertChar('v');
}
#+end_src



